///|
pub fn Input::new(chars : @string.View) -> Input {
  Input::{ chars, row: 0, col: 0 }
}

///|
pub fn ParseError::flatten(self : Self) -> Self {
  let xs = []
  fn dfs(root : ParseError) -> Unit {
    match root {
      Many(children) => children.each(dfs)
      Expect(_) => xs.push(root)
    }
  }

  dfs(self)
  Many(xs)
}

///|
pub fn[A] Parser::run(self : Parser[A], input : Input) -> A!ParseError {
  self(input).0
}

///|
pub fn[A] Parser::discard_spaces(self : Parser[A]) -> Parser[A] {
  spaces.discard_left(self)
}

///|
pub fnalias Parser::(
  between,
  bind,
  char,
  discard_left,
  discard_right,
  eof,
  label,
  map,
  none_of,
  one_of,
  round_bracket,
  square_bracket,
  curly_bracket,
  pure,
  run,
  satisfy,
  string,
  foldl,
  foldr,
  foldl1,
  foldr1,
  discard_spaces,
  many,
  many_each,
  map_srcpos,
  or
)

///|
pub fn[A] Parser::or(x : Parser[A], y : Parser[A]) -> Parser[A] {
  x | y
}
